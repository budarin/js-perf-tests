# Анализ результатов тестов производительности

Основной платформой для анализа производительности я вляется `linux`, так как все среды для контейнеризации используют именно эту операционную систему. Остальные платформы нужны лишь для подтверждения тенденций.

Результаты можно посмотреть в файле [node.v19.2.0.json](node.v19.2.0.json)

## Массивы

### indexOf as includes

Пример:

```js
if (arr.indexOf(item) > -1) {...}  // arr.includes(item)

if (arr.indexOf(item) >= 0) {...}  // arr.includes(item)

if (arr.indexOf(item) !== -1) {...}  // arr.includes(item)

if (arr.indexOf(item) === -1) {...}  // !arr.includes(item)

if (~arr.indexOf(item) ) {...}   // arr.includes(item)

if (!~arr.indexOf(item) ) {...}   // !arr.includes(v)
```

На всех платформах очевидно огромное преимущество в производительности `includes` над `indexOf` - сотни и тысячи процентов !

`Вывод`: необходимо трансформировать `indexOf` в `includes` в тех случаях, когда `indexOf` используется как `includes`

### Обращение к элементам массива при помощи деструктурирования их в переменные

Пример:

```js
const [a, b c] = arr;
```

vs

```js
const a = arr[0];
const b = arr[1];
const c = arr[2];
```

Очевидно, что деструктурирование элементов массива в переменные намного менее производительно чем доступ по индексу - несколько сотен процентов!

`Вывод`: необходимо трансформировать деструктурирование в обращение к элементам массива по индексу

### Создание инлайн массива при помощи деструктуририрования других массивов

Пример:

```js
const y = [...arr]; // arr.slice()
```

Создание массива при помощи деструктуризации единственного элемента равносильно использованию метода `slice` на этом массиве. `slice` выигрывает в производительности

`Вывод`: трансформировать деструктурирование единственного элемента при создании массива в вызов `slice` для него.

Пример:

```js
const x = [...arr, 1, 2, 3, ...arr1];
```

В большинстве случаев деструктурирование быстрее чем вызов метода `concat` для массивов.
Но реализация создания массива на основе цикла `for` в случаях, когда используется деструктурирование, во много раз производительнее чем деструктурирование.

`Вывод`: трансформировать создание массивов путем деструктурирования элементов в цикл `for`

### Map vs for

Реализация метода `map` при помощи цикла `for` более производительна за счет того, что

-   мы можем сразу создать массив нужно длины, а не добавлять по элементу за итерацию
-   не использовать проверки для редко используемых сценариев
-   испоьзуем предикаты только с первыми 2мя параметрами

Реализация метода на базе цикла показывает линейный рост с ростом количества элементов в массиве.
Особенно большой прирост производительности виден при обработке массивов с `float` - создание элемента массива наиболее дорогая операция по времени.

`Вывод`: необходима трансформация метода `map` в вызов цикла `for`

### ForEach, reduce

Реализация на базе цикла `for` показывает линейный рост производительности с ростом количества элементов в массиве
На нассивах размером в 3 элемента кастомная реализация показывает рост в 2 % и растет до 700 % на массивах с 10_000 элементов.

`Вывод`: трансформация целесообразна

### Join

Реализация на базе цикла `for` показывает лучшую производительность по сравнению с нативной реализацией

`Вывод`: трансформация целесообразна

### Join.trim

Реализация на базе цикла `for` показывает лучшую производительность по сравнению с нативной реализацией

`Вывод`: трансформация целесообразна

### Filter, find, some, every

Нативные реализации либо опережают по производительности реализацию при помощи цикла `for` либо не сильно уступают

`Вывод`: нет смысла в трансформации

### Цепоки вызовов циклических методов

Filter:

-   <array>.filter.map
-   <array>.filter.map.join
-   <array>.filter.map.join.trim

-   <array>.filter.reduce
-   <array>.filter.foreEach

Map:

-   <array>.map.map. ..

-   <array>.map.reduce
-   <array>.map.forEach

-   <array>.map.filter
-   <array>.map.filter.join
-   <array>.map.filter.join.trim

Join:

-   <array>.join.trim

За счет объединения нескольких циклов в один - результирующая производительность всегда будет выше исходной
В дополнение к более высокой производительности при реализации в одном цикле снижается производство "мусора" за счет того, что мы не создаем временные массивы

`Вывод`: необходима трансформация цепочек вызова в единый цикл `for`

## Строки

### Template vs string concatenation

Большой разницы между использованием шаблонов и конкатенацией при помощи оператора `+` и метода `concat` не наблюдается.

`Вывод`: трансформация не целесообразна

### Поиск подстроки при помощи includes vs indexOf

Особой разницы при использовании данных методов не наблюдается

`Вывод`: трансформация не целесообразна

## Числа

### Преобразование строк в числа

Конструктор `Number()` показывает огромное превосходство в производительности перед использованием методов `parseInt` и `parseFloat`

`Вывод`: необходима трансформация вызовов `parseInt` и `parseFloat` в вызов `Number()`

## Объекты

### Создание инлайн объектов при помощи деструктуририрования других объектов

Пример:

```js
const obj = { ...obj1, a: '1', b: true, ...obj2 };
```

vs

```js
const obj = Object.assign({}, obj1, { a: '1', b: true }, obj2);
```

`Object.assign` показывает огромное преимущество в производительности по сравнению с использованием деструктурирования - сотни процентов

`Вывод`: необходима трансформация деструктуризации в вызов `Object.assign`
